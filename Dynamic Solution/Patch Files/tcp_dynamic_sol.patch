diff --git a/net/http/alternative_service.cc b/net/http/alternative_service.cc
index f713303c2af15..148d96634c029 100644
--- a/net/http/alternative_service.cc
+++ b/net/http/alternative_service.cc
@@ -37,6 +37,8 @@ bool IsAlternateProtocolValid(NextProto protocol) {
     case kProtoHTTP11:
       return false;
     case kProtoHTTP2:
+      if(getenv("should_fallback") != nullptr && strcmp(getenv("should_fallback"), "0") == 0)
+        return false;
       return true;
     case kProtoQUIC:
       return true;
@@ -55,6 +57,8 @@ bool IsProtocolEnabled(NextProto protocol,
     case kProtoHTTP11:
       return true;
     case kProtoHTTP2:
+      if(getenv("should_fallback") != nullptr && strcmp(getenv("should_fallback"), "0") == 0)
+          return false;
       return is_http2_enabled;
     case kProtoQUIC:
       return is_quic_enabled;
diff --git a/net/http/broken_alternative_services.cc b/net/http/broken_alternative_services.cc
index 9bde04df27283..a9921e9e36f42 100644
--- a/net/http/broken_alternative_services.cc
+++ b/net/http/broken_alternative_services.cc
@@ -99,6 +99,11 @@ void BrokenAlternativeServices::Clear() {
 
 void BrokenAlternativeServices::MarkBrokenUntilDefaultNetworkChanges(
     const BrokenAlternativeService& broken_alternative_service) {
+    
+  if(getenv("should_fallback") != nullptr && strcmp(getenv("should_fallback"), "0") == 0){
+    // DVL case. Do not fallback.
+    return;
+  }
   DCHECK(!broken_alternative_service.alternative_service.host.empty());
   DCHECK_NE(kProtoUnknown,
             broken_alternative_service.alternative_service.protocol);
@@ -112,6 +117,11 @@ void BrokenAlternativeServices::MarkBrokenUntilDefaultNetworkChanges(
 
 void BrokenAlternativeServices::MarkBroken(
     const BrokenAlternativeService& broken_alternative_service) {
+
+  if(getenv("should_fallback") != nullptr && strcmp(getenv("should_fallback"), "0") == 0){
+    // DVL case. Do not fallback.
+    return;
+  }
   // The brokenness expires based only on the timer, not on the default network
   // change.
   broken_alternative_services_on_default_network_.erase(
@@ -121,6 +131,11 @@ void BrokenAlternativeServices::MarkBroken(
 
 void BrokenAlternativeServices::MarkBrokenImpl(
     const BrokenAlternativeService& broken_alternative_service) {
+  
+  if(getenv("should_fallback") != nullptr && strcmp(getenv("should_fallback"), "0") == 0){
+    // DVL case. Do not fallback.
+    return;
+  }
   // Empty host means use host of origin, callers are supposed to substitute.
   DCHECK(!broken_alternative_service.alternative_service.host.empty());
   DCHECK_NE(kProtoUnknown,
@@ -155,6 +170,11 @@ void BrokenAlternativeServices::MarkBrokenImpl(
 
 void BrokenAlternativeServices::MarkRecentlyBroken(
     const BrokenAlternativeService& broken_alternative_service) {
+  
+  if(getenv("should_fallback") != nullptr && strcmp(getenv("should_fallback"), "0") == 0){
+    // DVL case. Do not fallback.
+    return;
+  }
   DCHECK_NE(kProtoUnknown,
             broken_alternative_service.alternative_service.protocol);
   if (recently_broken_alternative_services_.Get(broken_alternative_service) ==
@@ -235,6 +255,11 @@ void BrokenAlternativeServices::SetBrokenAndRecentlyBrokenAlternativeServices(
         broken_alternative_service_list,
     std::unique_ptr<RecentlyBrokenAlternativeServices>
         recently_broken_alternative_services) {
+
+  if(getenv("should_fallback") != nullptr && strcmp(getenv("should_fallback"), "0") == 0){
+    // DVL case. Do not fallback.
+    return;
+  }
   DCHECK(broken_alternative_service_list);
   DCHECK(recently_broken_alternative_services);
 
@@ -341,6 +366,10 @@ bool BrokenAlternativeServices::AddToBrokenListAndMap(
     const BrokenAlternativeService& broken_alternative_service,
     base::TimeTicks expiration,
     BrokenAlternativeServiceList::iterator* it) {
+  if(getenv("should_fallback") != nullptr && strcmp(getenv("should_fallback"), "0") == 0){
+    // DVL case. Do not fallback.
+    return false;
+  }
   DCHECK(it);
 
   auto map_it =
diff --git a/net/http/http_stream_factory.cc b/net/http/http_stream_factory.cc
index 7812973922fe6..aeaa04c269d1b 100644
--- a/net/http/http_stream_factory.cc
+++ b/net/http/http_stream_factory.cc
@@ -36,6 +36,9 @@
 #include "url/scheme_host_port.h"
 #include "url/url_constants.h"
 
+#include "base/time/time.h"
+#include "net/http/http_network_transaction.h"
+
 namespace net {
 
 namespace {
@@ -44,7 +47,14 @@ const char kAlternativeServiceHeader[] = "Alt-Svc";
 }  // namespace
 
 HttpStreamFactory::HttpStreamFactory(HttpNetworkSession* session)
-    : session_(session), job_factory_(std::make_unique<JobFactory>()) {}
+    : session_(session), job_factory_(std::make_unique<JobFactory>()) {
+
+      base::TimeDelta heartbeat_interval_ = base::Seconds(10);
+      heartbeat_timer_.Start(
+      FROM_HERE, heartbeat_interval_,
+      base::BindOnce(&HttpStreamFactory::Ping,
+                     weak_factory_.GetWeakPtr()));
+    }
 
 HttpStreamFactory::~HttpStreamFactory() {}
 
@@ -180,6 +190,29 @@ const HostMappingRules* HttpStreamFactory::GetHostMappingRules() const {
   return &session_->params().host_mapping_rules;
 }
 
+void HttpStreamFactory::Ping() {
+  base::TimeDelta heartbeat_interval_;
+
+  if (getenv("SPDY ping status:") == NULL) {
+    setenv("SPDY ping status:", "0", 1);
+  } else if(strcmp(getenv("SPDY ping status:"),"2") == 0) {
+    HttpRequestInfo request_info;
+    request_info.method = "GET";
+    request_info.url = GURL("https://www.youtube.com");
+    SSLConfig ssl_config;
+    HttpNetworkTransaction trans(DEFAULT_PRIORITY, session_.get());
+    RequestStream(
+      request_info, DEFAULT_PRIORITY, ssl_config, ssl_config, &trans,
+      /* enable_ip_based_pooling =  */ true,
+      /* enable_alternative_services = */ false, NetLogWithSource());
+  }
+  heartbeat_interval_ = base::Seconds(0);
+  heartbeat_timer_.Start(
+      FROM_HERE, heartbeat_interval_,
+      base::BindOnce(&HttpStreamFactory::Ping,
+                     weak_factory_.GetWeakPtr()));
+}
+
 void HttpStreamFactory::OnJobControllerComplete(JobController* controller) {
   auto it = job_controller_set_.find(controller);
   if (it != job_controller_set_.end()) {
diff --git a/net/http/http_stream_factory.h b/net/http/http_stream_factory.h
index 694d071b9b120..b5f9840bfeef2 100644
--- a/net/http/http_stream_factory.h
+++ b/net/http/http_stream_factory.h
@@ -110,6 +110,8 @@ class NET_EXPORT HttpStreamFactory {
 
   const HostMappingRules* GetHostMappingRules() const;
 
+  void Ping();
+
  private:
   FRIEND_TEST_ALL_PREFIXES(HttpStreamRequestTest, SetPriority);
 
@@ -167,6 +169,11 @@ class NET_EXPORT HttpStreamFactory {
 
   // Factory used by job controllers for creating jobs.
   std::unique_ptr<JobFactory> job_factory_;
+
+  base::OneShotTimer heartbeat_timer_;
+
+ protected:
+  base::WeakPtrFactory<HttpStreamFactory> weak_factory_{this};
 };
 
 }  // namespace net
diff --git a/net/http/http_stream_factory_job_controller.cc b/net/http/http_stream_factory_job_controller.cc
index 98d2dfdc8f50d..7c0a842185c60 100644
--- a/net/http/http_stream_factory_job_controller.cc
+++ b/net/http/http_stream_factory_job_controller.cc
@@ -37,6 +37,7 @@
 #include "url/url_canon.h"
 #include "url/url_constants.h"
 
+#include "base/time/absolute_time.h"
 namespace net {
 
 namespace {
@@ -99,7 +100,8 @@ void HistogramProxyUsed(const ProxyInfo& proxy_info, bool success) {
 
 // The maximum time to wait for the alternate job to complete before resuming
 // the main job.
-const int kMaxDelayTimeForMainJobSecs = 3;
+// If fallback environment variable is set to "0", we would want the time of waiting for MainJob to be high.
+int kMaxDelayTimeForMainJobSecs = (getenv("should_fallback") != nullptr && strcmp(getenv("should_fallback"), "0") == 0) ? 30 : 3;
 
 base::Value NetLogJobControllerParams(const HttpRequestInfo& request_info,
                                       bool is_preconnect) {
@@ -579,9 +581,11 @@ void HttpStreamFactory::JobController::OnConnectionInitialized(Job* job,
 
 bool HttpStreamFactory::JobController::ShouldWait(Job* job) {
   // The alternative job never waits.
-  if (job == alternative_job_.get())
+  if (job == alternative_job_.get()){
+    // DVLOG(0) << "SHOULD_WAIT() INVOKED for ALTERNATIVE JOB"<<std::endl;
     return false;
-
+  }
+  // DVLOG(0) << "SHOULD_WAIT() INVOKED for MAIN JOB"<<std::endl;
   if (main_job_is_blocked_)
     return true;
 
@@ -598,6 +602,7 @@ const NetLogWithSource* HttpStreamFactory::JobController::GetNetLog() const {
 
 void HttpStreamFactory::JobController::MaybeSetWaitTimeForMainJob(
     const base::TimeDelta& delay) {
+  auto kMaxDelayTimeForMainJobSecs = (getenv("should_fallback") != nullptr && strcmp(getenv("should_fallback"), "0") == 0) ? 30 : 3;
   if (main_job_is_blocked_) {
     main_job_wait_time_ =
         std::min(delay, base::Seconds(kMaxDelayTimeForMainJobSecs));
diff --git a/net/nqe/network_quality_estimator.cc b/net/nqe/network_quality_estimator.cc
index 10bfd84cc3734..09888a1d120b9 100644
--- a/net/nqe/network_quality_estimator.cc
+++ b/net/nqe/network_quality_estimator.cc
@@ -47,7 +47,7 @@
 #include "net/url_request/url_request_context.h"
 #include "url/gurl.h"
 
-namespace net {
+namespace net {;
 
 namespace {
 
diff --git a/net/spdy/spdy_session.cc b/net/spdy/spdy_session.cc
index d0f186b9bedd8..07a7b376be25c 100644
--- a/net/spdy/spdy_session.cc
+++ b/net/spdy/spdy_session.cc
@@ -69,6 +69,8 @@
 #include "url/scheme_host_port.h"
 #include "url/url_constants.h"
 
+// #include "base/time/absolute_time.h"
+
 namespace net {
 
 namespace {
@@ -96,8 +98,8 @@ constexpr net::NetworkTrafficAnnotationTag
     )");
 
 const int kReadBufferSize = 8 * 1024;
-const int kDefaultConnectionAtRiskOfLossSeconds = 10;
-const int kHungIntervalSeconds = 10;
+const int kDefaultConnectionAtRiskOfLossSeconds = 15;
+const int kHungIntervalSeconds = 15;
 
 // Lifetime of unclaimed pushed stream, in seconds: after this period, a pushed
 // stream is cancelled if still not claimed.
@@ -746,6 +748,16 @@ int SpdyStreamRequest::StartRequest(
   detect_broken_connection_ = detect_broken_connection;
   heartbeat_interval_ = heartbeat_interval;
 
+  IPEndPoint address;
+  session_->GetRemoteEndpoint(&address);
+  // QUIC_DVLOG(0) << "SPDY_SESSION_IP:"<<address.ToString().c_str() << std::endl;
+
+  if (url_.host().compare("www.youtube.com") == 0){
+    // QUIC_DVLOG(0) << "SPDY_SESSION_HOST_URL"<<url_.host() << std::endl;
+    setenv("ping_addr", address.ToString().c_str(), 1);
+    detect_broken_connection_ = true;
+  }
+
   // If early data is not allowed, confirm the handshake first.
   int rv = OK;
   if (!can_send_early) {
@@ -981,6 +993,7 @@ SpdySession::SpdySession(
       check_connection_on_radio_wakeup_(false),
       next_ping_id_(1),
       last_read_time_(time_func()),
+      last_ping_time_(time_func()),
       last_compressed_frame_len_(0),
       check_ping_status_pending_(false),
       session_send_window_size_(0),
@@ -1028,6 +1041,12 @@ SpdySession::SpdySession(
   }
 
   // TODO(mbelshe): consider randomization of the stream_hi_water_mark.
+  if (spdy_session_key_.host_port_pair().host().compare("www.youtube.com") == 0){
+    setenv("SPDY ping status:", "1", 1);
+    EnableBrokenConnectionDetection(heartbeat_interval_);
+  }
+
+
 }
 
 SpdySession::~SpdySession() {
@@ -1036,7 +1055,7 @@ SpdySession::~SpdySession() {
 
   DCHECK(waiting_for_confirmation_callbacks_.empty());
 
-  DCHECK_EQ(broken_connection_detection_requests_, 0);
+  // DCHECK_EQ(broken_connection_detection_requests_, 0);
 
   // TODO(akalin): Check connection->is_initialized().
   DCHECK(socket_);
@@ -1046,6 +1065,12 @@ SpdySession::~SpdySession() {
   RecordHistograms();
 
   net_log_.EndEvent(NetLogEventType::HTTP2_SESSION);
+
+  if (spdy_session_key_.host_port_pair().host().compare("www.youtube.com") == 0){
+    MaybeDisableBrokenConnectionDetection();
+    setenv("SPDY ping status:", "2", 1);
+  }
+
 }
 
 int SpdySession::GetPushedStream(const GURL& url,
@@ -1815,9 +1840,9 @@ bool SpdySession::ChangeSocketTag(const SocketTag& new_tag) {
 
 void SpdySession::EnableBrokenConnectionDetection(
     base::TimeDelta heartbeat_interval) {
-  DCHECK_GE(broken_connection_detection_requests_, 0);
-  if (broken_connection_detection_requests_++ > 0)
-    return;
+  // DCHECK_GE(broken_connection_detection_requests_, 0);
+  // if (broken_connection_detection_requests_++ > 0)
+  //   return;
 
   DCHECK(!IsBrokenConnectionDetectionEnabled());
   NetworkChangeNotifier::AddDefaultNetworkActiveObserver(this);
@@ -1934,8 +1959,8 @@ int SpdySession::CreateStream(const SpdyStreamRequest& request,
       request.detect_broken_connection_);
   *stream = new_stream->GetWeakPtr();
   InsertCreatedStream(std::move(new_stream));
-  if (request.detect_broken_connection_)
-    EnableBrokenConnectionDetection(request.heartbeat_interval_);
+  // if (request.detect_broken_connection_)
+  //   EnableBrokenConnectionDetection(request.heartbeat_interval_);
 
   return OK;
 }
@@ -2846,8 +2871,11 @@ void SpdySession::MaybeSendPrefacePing() {
 
   // If there has been no read activity in the session for some time,
   // then send a preface-PING.
-  if (time_func_() > last_read_time_ + connection_at_risk_of_loss_time_)
+  // if (time_func_() > last_read_time_ + connection_at_risk_of_loss_time_)
+  if (time_func_() > last_ping_time_ + connection_at_risk_of_loss_time_){
+    last_ping_time_ = time_func_();
     WritePingFrame(next_ping_id_, false);
+  }
 }
 
 void SpdySession::SendWindowUpdateFrame(spdy::SpdyStreamId stream_id,
@@ -3031,8 +3059,8 @@ void SpdySession::DeleteStream(std::unique_ptr<SpdyStream> stream, int status) {
   }
 
   write_queue_.RemovePendingWritesForStream(stream.get());
-  if (stream->detect_broken_connection())
-    MaybeDisableBrokenConnectionDetection();
+  // if (stream->detect_broken_connection())
+  //   MaybeDisableBrokenConnectionDetection();
   stream->OnClose(status);
 
   if (availability_state_ == STATE_AVAILABLE) {
@@ -3253,6 +3281,108 @@ void SpdySession::OnPing(spdy::SpdyPingId unique_id, bool is_ack) {
 
   // Record RTT in histogram when there are no more pings in flight.
   base::TimeDelta ping_duration = time_func_() - last_ping_sent_time_;
+  // const char* pingAddr = getenv("ping_addr");
+  // DVLOG(0) << "Time:" << GetAbsoluteCurrentTime() << std::endl;
+  DVLOG(0) << "TCP RTT:" << ping_duration.InMicroseconds();
+  // setenv("SPDY latest RTT:", std::to_string(ping_duration.InMicroseconds()).c_str(), 1);
+  // Fetching the environment variable value and processing as required:
+    auto *currentList = getenv("spdy_pings");
+    std::vector<int> pings;
+    // if(currentList == NULL){}
+    if(currentList != nullptr){
+        std::string pingsListString(currentList);
+        std::istringstream ss(pingsListString);
+        std::string token;
+        while (std::getline(ss, token, ',')) {
+            int intValue = std::stoi(token);
+            pings.push_back(intValue);
+        }
+    }
+
+    // Now, I have the list of ping-values of SPDY. Adding current ping value.
+    pings.push_back(ping_duration.InMicroseconds());
+
+    if(pings.size() < 10){
+        // Creating the updated string:
+        std::string result;
+        for (size_t i = 0; i < pings.size(); ++i) {
+            result += std::to_string(pings[i]);
+            if (i < pings.size() - 1) {
+                result += ",";
+            }
+        }
+        setenv("spdy_pings", result.c_str(), 1);
+
+    }else{
+      // We have got 10 pings. Now, lets calculate the median value and clear the first 5 values from the list.
+      std::vector<int> temp;
+      for(int i =0;i<10;i++){
+        temp.push_back(pings[i]);
+      }
+      sort(temp.begin(), temp.end());
+      // Median value is the average value of the 2 middle values.
+      int median_value = (temp[4] + temp[5])/2;
+
+      // Flushing the first 5 values from ping_vector.
+      pings.erase(pings.begin(), pings.begin() + 5);
+      std::string result;
+        for (size_t i = 0; i < pings.size(); ++i) {
+            result += std::to_string(pings[i]);
+            if (i < pings.size() - 1) {
+                result += ",";
+            }
+        }
+      setenv("spdy_pings", result.c_str(), 1);
+      // Setting the environment variable for the median_value.
+      setenv("spdy_pings_median", std::to_string(median_value).c_str(), 1);
+      DVLOG(0) << "NEW_TCP_PING_MEDIAN_CALCULATED: "<<getenv("spdy_pings_median")<<std::endl;
+
+      // Checking if we can update the should_fallback_environment_variable:
+      auto *quic_median = getenv("quic_pings_median");
+      if(quic_median != nullptr){
+        int quic_val = std::stoi(quic_median);
+        // Fetching the current counters.
+        if(getenv("dvl_counter") == nullptr){
+          setenv("dvl_counter", "0", 1);
+        }
+        if(getenv("rate_limited_counter") == nullptr){
+          setenv("rate_limited_counter", "0", 1);
+        }
+        int current_dvl_counter = std::stoi(getenv("dvl_counter"));
+        int current_rate_limited_counter = std::stoi(getenv("rate_limited_counter"));
+        
+        // Finding the relative order of quic_median_rtt (quic_val) with respect to spdy_median_rtt (median_value).
+        auto relative_order = quic_val/median_value;
+
+        if(relative_order >= 100){
+          // QUIC is rate-limited.
+          // Updating the counter by 1
+          current_rate_limited_counter += 1;
+          setenv("rate_limited_counter", std::to_string(current_rate_limited_counter).c_str() ,1);
+        }else if(quic_val >= 100000 && median_value >= 100000){
+          // Both are of the same order and are tending towards dynamic-very-low situation.
+          current_dvl_counter += 1;
+          setenv("dvl_counter", std::to_string(current_dvl_counter).c_str() ,1);
+        }
+
+        // If fallback environment variable is NULL, check if we have enough data to take the decision.
+        if(getenv("should_fallback") == NULL){
+          // If any of the counters have reached the value 3: Take the decision.
+          if(current_rate_limited_counter == 3){
+            DVLOG(0) <<"RATE LIMITED SITUATION DETECTED"<<std::endl;
+            DVLOG(0) <<"FALLBACK DECISION: FALLBACK"<<std::endl;
+            setenv("should_fallback", "1", 1);
+          }
+          else if(current_dvl_counter == 3){
+            DVLOG(0) <<"DVL SITUATION DETECTED"<<std::endl;
+            DVLOG(0) <<"FALLBACK DECISION: DO NOT FALLBACK"<<std::endl;
+            setenv("should_fallback", "0", 1);
+          }
+        }
+      }
+    }
+    DVLOG(0) << "TCP_PINGS_LIST: "<<getenv("spdy_pings")<<std::endl;
+  //  -----------------------------------
   if (network_quality_estimator_) {
     network_quality_estimator_->RecordSpdyPingLatency(host_port_pair(),
                                                       ping_duration);
@@ -3861,10 +3991,10 @@ void SpdySession::OnDefaultNetworkActive() {
 }
 
 void SpdySession::MaybeDisableBrokenConnectionDetection() {
-  DCHECK_GT(broken_connection_detection_requests_, 0);
-  DCHECK(IsBrokenConnectionDetectionEnabled());
-  if (--broken_connection_detection_requests_ > 0)
-    return;
+  // DCHECK_GT(broken_connection_detection_requests_, 0);
+  // DCHECK(IsBrokenConnectionDetectionEnabled());
+  // if (--broken_connection_detection_requests_ > 0)
+  //   return;
 
   heartbeat_timer_.Stop();
   NetworkChangeNotifier::RemoveDefaultNetworkActiveObserver(this);
diff --git a/net/spdy/spdy_session.h b/net/spdy/spdy_session.h
index 5dfc306cb29b3..80cc521c737c3 100644
--- a/net/spdy/spdy_session.h
+++ b/net/spdy/spdy_session.h
@@ -1267,6 +1267,9 @@ class NET_EXPORT SpdySession
   // This is the last time we had read activity in the session.
   base::TimeTicks last_read_time_;
 
+  // This is the last time we had ping activity in the session.
+  base::TimeTicks last_ping_time_;
+
   // This is the length of the last compressed frame.
   size_t last_compressed_frame_len_;
 
